<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Webcam Processing</title>
    <style>
      video,
      canvas {
        display: none;
        margin: 20px auto;
      }
      .controls {
        text-align: center;
        margin-bottom: 20px;
      }
    </style>
  </head>
  <body>
    <h1>Webcam Processing</h1>
    <div id="controls" class="controls"></div>
    <video id="video" autoplay style="display: none"></video>
    <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script>
      const video = document.getElementById("video");
      const controls = document.getElementById("controls");

      let streaming = false;
      let p5Instances = {};

      //Effects
      const effects = [
        {
          name: "Video",
          type: "toggle",
          setup: () => {},
          process: () => {},
          toggle: (active) => {
            video.style.display = active ? "block" : "none";
          },
        },
        {
          name: "Edge Detection",
          type: "opencv",
          setup: () => {
            const canvas = document.createElement("canvas");
            canvas.id = "canvasEdges";
            canvas.style.display = "none";
            document.body.appendChild(canvas);
            return canvas.getContext("2d");
          },
          process: (ctx) => {
            ctx.drawImage(video, 0, 0, ctx.canvas.width, ctx.canvas.height);
            let src = cv.imread(ctx.canvas);
            let dst = new cv.Mat();
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY);
            cv.Canny(src, dst, 50, 100);
            cv.imshow(ctx.canvas, dst);
            src.delete();
            dst.delete();
          },
        },
        {
          name: "Pixelation",
          type: "manual",
          setup: () => {
            const canvas = document.createElement("canvas");
            canvas.id = "canvasPixelation";
            canvas.style.display = "none";
            document.body.appendChild(canvas);
            return canvas.getContext("2d");
          },
          process: (ctx) => {
            ctx.drawImage(video, 0, 0, ctx.canvas.width, ctx.canvas.height);
            let imageData = ctx.getImageData(
              0,
              0,
              ctx.canvas.width,
              ctx.canvas.height
            );
            let data = imageData.data;
            let pixelSize = 20;
            for (let y = 0; y < ctx.canvas.height; y += pixelSize) {
              for (let x = 0; x < ctx.canvas.width; x += pixelSize) {
                let red = data[(ctx.canvas.width * y + x) * 4];
                let green = data[(ctx.canvas.width * y + x) * 4 + 1];
                let blue = data[(ctx.canvas.width * y + x) * 4 + 2];
                for (let n = 0; n < pixelSize; n++) {
                  for (let m = 0; m < pixelSize; m++) {
                    if (x + m < ctx.canvas.width && y + n < ctx.canvas.height) {
                      data[(ctx.canvas.width * (y + n) + (x + m)) * 4] = red;
                      data[(ctx.canvas.width * (y + n) + (x + m)) * 4 + 1] =
                        green;
                      data[(ctx.canvas.width * (y + n) + (x + m)) * 4 + 2] =
                        blue;
                    }
                  }
                }
              }
            }
            ctx.putImageData(imageData, 0, 0);
          },
        },
        {
          name: "Blur",
          type: "opencv",
          setup: () => {
            const canvas = document.createElement("canvas");
            canvas.id = "canvasBlur";
            canvas.style.display = "none";
            document.body.appendChild(canvas);
            return canvas.getContext("2d");
          },
          process: (ctx) => {
            ctx.drawImage(video, 0, 0, ctx.canvas.width, ctx.canvas.height);
            let src = cv.imread(ctx.canvas);
            let dst = new cv.Mat();
            cv.GaussianBlur(src, dst, new cv.Size(15, 15), 0);
            cv.imshow(ctx.canvas, dst);
            src.delete();
            dst.delete();
          },
        },
        {
          name: "Invert Colors",
          type: "manual",
          setup: () => {
            const canvas = document.createElement("canvas");
            canvas.id = "canvasInvert";
            canvas.style.display = "none";
            document.body.appendChild(canvas);
            return canvas.getContext("2d");
          },
          process: (ctx) => {
            ctx.drawImage(video, 0, 0, ctx.canvas.width, ctx.canvas.height);
            let imageData = ctx.getImageData(
              0,
              0,
              ctx.canvas.width,
              ctx.canvas.height
            );
            let data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
              data[i] = 255 - data[i];
              data[i + 1] = 255 - data[i + 1];
              data[i + 2] = 255 - data[i + 2];
            }
            ctx.putImageData(imageData, 0, 0);
          },
        },
        {
          name: "Noise Effect",
          type: "p5",
          setup: () => {
            return (p) => {
              let capture;
              let skip;

              p.setup = function () {
                let cnv = p.createCanvas(640, 480);
                cnv.id("noiseCanvas");
                cnv.style("display", "none");
                capture = p.createCapture(p.VIDEO);
                capture.size(640, 480);
                capture.hide();
                p.resetSketch();
              };

              p.resetSketch = function () {
                skip = p.floor(p.random(10, 30));
              };

              p.draw = function () {
                if (
                  !p.canvas.style.display ||
                  p.canvas.style.display === "none"
                )
                  return;
                p.background(0);
                let w = capture.width;
                let h = capture.height;
                p.translate(p.width / 2 - w / 2, p.height / 2 - h / 2);
                for (let i = 0; i < w; i += skip) {
                  let rec = capture.get(p.noise(i * 100) * w, 0, skip, h);
                  p.image(rec, i, 0, skip, h);
                }
              };
            };
          },
        },
        {
          name: "Slice Effect",
          type: "p5",
          setup: () => {
            return (p) => {
              let capture;
              let slices = [];
              let sliceWidth;

              p.setup = function () {
                let cnv = p.createCanvas(640, 480);
                cnv.id("sliceCanvas");
                cnv.style("display", "none");
                capture = p.createCapture(p.VIDEO);
                capture.size(640, 480);
                capture.hide();
                p.resetSketch();
              };

              p.resetSketch = function () {
                slices = [];
                sliceWidth = p.floor(p.random(6, 41));
                let numSlices = Math.floor(p.width / sliceWidth);
                let sourcePositions = Array.from(
                  { length: numSlices },
                  (_, i) => i * sliceWidth
                );
                for (let i = sourcePositions.length - 1; i > 0; i--) {
                  const j = Math.floor(Math.random() * (i + 1));
                  [sourcePositions[i], sourcePositions[j]] = [
                    sourcePositions[j],
                    sourcePositions[i],
                  ];
                }
                for (let i = 0; i < numSlices; i++) {
                  slices.push({
                    sourceX: sourcePositions[i],
                    destX: i * sliceWidth,
                    width: sliceWidth,
                  });
                }
                let remainingPixels = p.width - numSlices * sliceWidth;
                if (remainingPixels > 0 && slices.length > 0) {
                  let lastSlice = slices[slices.length - 1];
                  lastSlice.width += remainingPixels;
                }
              };

              p.draw = function () {
                if (
                  !p.canvas.style.display ||
                  p.canvas.style.display === "none"
                )
                  return;
                p.background(0);
                for (let slice of slices) {
                  let img = capture.get(
                    slice.sourceX,
                    0,
                    slice.width,
                    p.height
                  );
                  p.image(img, slice.destX, 0, slice.width, p.height);
                }
              };
            };
          },
        },
      ];

      // Utility functions
      function startVideo() {
        navigator.mediaDevices
          .getUserMedia({ video: true })
          .then((stream) => {
            video.srcObject = stream;
            video.play();
          })
          .catch((err) => console.error("Error accessing the camera: " + err));
      }

      function setupEffects() {
        effects.forEach((effect, index) => {
          const button = document.createElement("button");
          button.textContent = `Toggle ${effect.name}`;
          button.addEventListener("click", () => toggleEffect(index));
          controls.appendChild(button);

          if (effect.type !== "toggle" && effect.type !== "p5") {
            effect.ctx = effect.setup();
          }

          effect.active = false;
        });
      }

      function toggleEffect(index) {
        const effect = effects[index];
        effect.active = !effect.active;

        if (effect.type === "toggle") {
          effect.toggle(effect.active);
        } else if (effect.type === "p5") {
          if (effect.active) {
            if (!p5Instances[index]) {
              p5Instances[index] = new p5(effect.setup());
            } else {
              // Reset the sketch when reactivating
              p5Instances[index].resetSketch();
            }
            p5Instances[index].canvas.style.display = "block";
          } else if (p5Instances[index]) {
            p5Instances[index].canvas.style.display = "none";
          }
        } else {
          effect.ctx.canvas.style.display = effect.active ? "block" : "none";
        }
      }

      function processFrame() {
        if (!streaming) return;

        effects.forEach((effect) => {
          if (
            effect.active &&
            effect.type !== "toggle" &&
            effect.type !== "p5"
          ) {
            effect.process(effect.ctx);
          }
        });

        requestAnimationFrame(processFrame);
      }

      video.addEventListener("canplay", () => {
        if (!streaming) {
          streaming = true;
          effects.forEach((effect) => {
            if (effect.type !== "toggle" && effect.type !== "p5") {
              effect.ctx.canvas.width = video.videoWidth;
              effect.ctx.canvas.height = video.videoHeight;
            }
          });
          processFrame();
        }
      });

      startVideo();
      setupEffects();
    </script>
  </body>
</html>
